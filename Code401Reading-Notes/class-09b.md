## OAuth 2 Simplified
### Roles
* The Third-Party Application: 
    * "Client" : The client is the application that is attempting to get access to the user's account. It needs to get permission from the user before it can do so.

* The API:
    *  "Resource Server" : The resource server is the API server used to access the user's information.

* The Authorization Server : 
    * This is the server that presents the interface where the user approves or denies the request. In smaller implementations, this may be the same server as the API server, but larger scale deployments will often build this as a separate component.
* The User: 
    "Resource Owner" : The resource owner is the person who is giving access to some portion of their account.
* creating an App
    * When registering a new app, you usually register basic information such as application name, website, a logo, etc. In addition, you must register a redirect URI to be used for redirecting users to for web server, browser-based, or mobile apps.
* Redirect URIs
    * The service will only redirect users to a registered URI, which helps prevent some attacks. Any HTTP redirect URIs must be served via HTTPS
* Client ID and Secret
    * After registering your app, you will receive a client ID and optionally a client secret. The client ID is considered public information, and is used to build login URLs, or included in Javascript source code on a page. 
### Authorization
* Authorization Code for apps running on a web server, browser-based and mobile apps
* Password for logging in with a username and password (only for first-party apps)
* Client credentials for application access without a user present
* Implicit was previously recommended for clients without a secret, but has been superseded by using the Authorization Code grant with PKCE.
### Web Server Apps
* response_type=code - Indicates that your server expects to receive an authorization code
* client_id - The client ID you received when you first created the application
* redirect_uri - Indicates the URI to return the user to after authorization is complete
* scope - One or more scope values indicating which parts of the user's account you wish to access
* state - A random string generated by your application, which you'll verify later
### Getting an Access Token
* grant_type=authorization_code - The grant type for this flow is authorization_code
* code=AUTH_CODE_HERE - This is the code you received in the query string
* redirect_uri=REDIRECT_URI - Must be identical to the redirect URI provided in the original link
* client_id=CLIENT_ID - The client ID you received when you first created the application
* client_secret=CLIENT_SECRET - Since this request is made from server-side code, the secret is included
### Other Grant Types
#### Password
OAuth 2 also provides a "password" grant type which can be used to exchange a username and password for an access token directly. Since this obviously requires the application to collect the user's password, it must only be used by apps created by the service itself. 
* grant_type=password - The grant type for this flow is password
* username=USERNAME - The user's username as collected by the application
* password=PASSWORD - The user's password as collected by the application
* client_id=CLIENT_ID - The client ID you received when you first created the application
#### Making Authenticated Requests
The end result of all the grant types is obtaining an access token.
#### Differences from OAuth 1.0
OAuth 1.0 was largely based on existing proprietary protocols such as Flickr's "FlickrAuth" and Google's "AuthSub"
## Build a Simple REST API with Node and OAuth 2.0
### Secure Your Node + Express REST API with OAuth 2.0
Now that you have a REST API up and running, imagine you’d like a specific application to use this from a remote location. If you host this on the internet as is, then anybody can add, modify, or remove parts at their will.

To avoid this, you can use the OAuth 2.0 Client Credentials Flow. This is a way of letting two servers communicate with each other, without the context of a user. The two servers must agree ahead of time to use a third-party authorization server. Assume there are two servers, A and B, and an authorization server. Server A is hosting the REST API, and Server B would like to access the API.

* Server B sends a secret key to the authorization server to prove who they are and asks for a temporary token.
* Server B then consumes the REST API as usual but sends the token along with the request.
* Server A asks the authorization server for some metadata that can be used to verify tokens.
* Server A verifies the Server B’s request.
    * If it’s valid, a successful response is sent and Server B is happy.
    * If the token is invalid, an error message is sent instead, and no sensitive information is leaked.
